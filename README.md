# .NET Distributed Application

## Overview
Sample application using .NET to test and demonstrate techniques/patterns to use when building a real-world distributed application.

I have various goals for this project (listed below) where each demonstrates or contributes towards a feature needed when building a real-world distributed application.
Some goals have value just within themselves. Some goals will also drive out other useful best practice patterns.

<!-- Use &#x2610; for unticked, &#x2611; for ticked --> 

| Goals                                                                                                     | Implementation                                                                                                                                                                                                                                     |
|-----------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| &#x2611; Has its own RESTful API                                                                          | Simple minimal API using weather data stored in Postgres database                                                                                                                                                                                  |
| &#x2611; Has its own data store (SQL or non-SQL)                                                          | Postgres database accessed using EF Core                                                                                                                                                                                                           |
| &#x2611; Make use of an upstream RESTful API (i.e., another microservice)                                 | SpatialApi endpoint is called from Api/weather/stations to enrich weather/location data                                                                                                                                                            |
| &#x2611; Make use of a third party external API                                                           | Use observabilitystack/geoip-api which is a Docker image that exposes a REST endpoint<br/> Supplement GetWeatherStations() responses with Geo data                                                                                                 |
| &#x2610; Make use of asynchronous messaging                                                               | Kafka; create consumer process                                                                                                                                                                                                                     |
| &#x2611; Use different caching strategies                                                                 | Using Redis and StackExchange client<br/>Using output caching on GetWeatherStationHistoricData endpoint (API logs show cache miss/set/hit)<br/>Using cache-aside for GeoIP information (used by GetWeatherStations)                                |
| &#x2611; Use appropriate levels of testing, i.e., unit, integration, end-to-end                           | Just have integration tests that demonstrate hooking into Aspire, as that is the purpose of this project                                                                                                                                           |
| &#x2611; Resilience: Calls to the data store retry on failure                                             | Using EF Core EnableRetryOnFailure()<br/>Test by stopping Postgres server from Aspire dashboard, making calls via SwaggerUI and watching API container logs                                                                                        |
| &#x2610; Resilience: Calls to other APIs retry on failure                                                 | HttpClient + Polly                                                                                                                                                                                                                                 |
| &#x2610; Resilience: Consuming asynchronous messages retry on failure                                     | With Kafka the consumer needs the logic; have an out-of-order topic with its own consumer which push back to the target topic                                                                                                                      |
| &#x2610; Resilience: Should use appropriate strategies,  i.e., exponential backoff, circuit-breaker, etc. | Polly can do this for when calling other HTTP services                                                                                                                                                                                             |
| &#x2610; Resilience: Rate limiting and load shedding                                                      | ASP.NET Core rate limiting middleware: https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit <br/>Use a load shedding package such as: https://github.com/Farfetch/loadshedding                                                     |
| &#x2611; Logging: Use structured logging                                                                  | Using Serilog as it gives more features                                                                                                                                                                                                            |
| &#x2610; Logging: Exception logging                                                                       | See https://www.milanjovanovic.tech/blog/global-error-handling-in-aspnetcore-from-middleware-to-modern-handlers                                                                                                                                    |
| &#x2610; Logging: Trace a single request across multiple services                                         | HttpClient can do this. What about EF Core and Kafka client? Return the correlation id in the response. Give "data" and "meta" in the response. Wrap lists.                                                                                        |
| &#x2610; Logging: View, search and filter logs                                                            | Aspire dashboard initially, then Prometheus + Graphana.                                                                                                                                                                                            |
| &#x2610; Metrics: Record standard, out-of-the-box metrics                                                 | Aspire + OpenTelemetry                                                                                                                                                                                                                             |
| &#x2610; Metrics: Record custom metrics                                                                   | OpenTelemetry + [.NET custom metrics](https://opentelemetry.io/docs/zero-code/dotnet/custom/)                                                                                                                                                      |
| &#x2610; Metrics: Visualise and filter metrics                                                            | Aspire dashboard initially, then Prometheus + Graphana. See https://learn.microsoft.com/en-us/samples/dotnet/aspire-samples/aspire-metrics/ and https://www.milanjovanovic.tech/blog/monitoring-dotnet-applications-with-opentelemetry-and-grafana |
| &#x2611; Developer inner-loop: All components be easily deployed locally                                  | Using Aspire                                                                                                                                                                                                                                       |
| &#x2610; Deployment: All components be easily deployed to the Cloud                                       | Aspire + azd to Azure Container Apps                                                                                                                                                                                                               |
| &#x2610; Deployment: Deployed in a way that scales horizontally                                           | Aspire and Azure Container Apps (or Kubernetes) does this                                                                                                                                                                                          |
| &#x2610; Deployment: Cloud-provider agnostic                                                              | Aspire + [Aspir8](https://prom3theu5.github.io/aspirational-manifests/getting-started.html) to Kubernetes. See also https://medium.com/@josephsims1/aspire-aspi8-deploy-microservices-effortlessly-with-cli-no-docker-or-yaml-needed-f30b58443107  |
| &#x2610; Authn & Authz: Anon vs user vs admin endpoints                                                   | Keycloak + user vs admin client scopes + simple React app                                                                                                                                                                                          |
| &#x2610; Authn & Authz: Service-to-service calls                                                          | Keycloak + client id & secret and client scopes                                                                                                                                                                                                    |
